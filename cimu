#!/bin/bash

# ▄████▄   ██▓ ███▄ ▄███▓ █    ██ 
# ▒██▀ ▀█  ▓██▒▓██▒▀█▀ ██▒ ██  ▓██▒
# ▒▓█    ▄ ▒██▒▓██    ▓██░▓██  ▒██░
# ▒▓▓▄ ▄██▒░██░▒██    ▒██ ▓▓█  ░██░
# ▒ ▓███▀ ░░██░▒██▒   ░██▒▒▒█████▓ 
# ░ ░▒ ▒  ░░▓  ░ ▒░   ░  ░░▒▓▒ ▒ ▒ 
# ░  ▒    ▒ ░░  ░      ░░░▒░ ░ ░ 
# ░         ▒ ░░      ░    ░░░ ░ ░ 
# ░ ░       ░         ░      ░     
# ░                                
# Tool that can run what AWX GitHub Actions runs, but different.
# 0.2.0 "Switches on Everything"
CIMU_VERSION=0.2.0

# NOTE: There's a great-looking github action local runner here:
#   https://github.com/nektos/act
# GitHub's full-blown runner is here:
#   https://github.com/actions/runner
# But, for now I think this'll do the trick.

# We're evolving into a tool for bootstrapping, wrapping and running tests and
# dev instances of AWX.

error () {
	  echo >&2 "error: $*"
	  exit 1
}
install_deps_rhel8() {
    # Install deps that I needed on rhel8 in order to use
    # the awx repo, dev and build tools.
    # I'm not sure what's needed on other environments right now,
    # but I know I've done similar installs on Fedora {37,38}
    # too.
    sudo dnf install openldap-devel \
        postgresql postgresql-devel \
        xmlsec1-devel libxml2-devel \
        libtool-ltdl-devel
}
install_deps() {
    install_deps_rhel8
}
# Stash the realmake early in case we clobber it or need to call it at a different level
realmake=$(command -v make)
envmake() {
    # envmake will run make and use environment variables to override any
    # make variables.
    echo "inside envmake about to call realmake with overrides" >&2
    echo "realmake is: ${realmake}" >&2
    echo "version env vars from envmake(): VERSION=${VERSION}, COLLECTION_VERSION=${COLLECTION_VERSION}" >&2
    "${realmake}" --environment-overrides "$@"
}
make() {
    envmake "$@"
}
# TODO(jjwatt): define docker(), too so that I can control calls to that.
# e.g., probably want to capture calls to 'docker info' to avoid bugs
# in the main.yml playbook and getting os info.
pip_uninstalls() {
    # TODO: ihateyoupip array and try to uninstall all of it
    pip uninstall -y setuptools-scm ansible-core || :
}
set_branch() {
    # set_branch will set the GIT_BRANCH, COMPOSE_TAG, DEV_DOCKER_TAG_BASE,
    # and DEVEL_IMAGE_NAME to the right stuff like the Makefile does.
    # Use this to force pulling the devel docker image or an arbitrary
    # docker image vs. needing to build your own.
    export GIT_BRANCH="$1"
    shift
    export COMPOSE_TAG="${GIT_BRANCH}"
    # All this just stolen from the Makefile for now
    # TODO(jjwatt): Refactor
    export DEV_DOCKER_TAG_BASE=${DEV_DOCKER_TAG_BASE:-ghcr.io/ansible}
    export DEVEL_IMAGE_NAME=${DEV_DOCKER_TAG_BASE}/awx_devel:${COMPOSE_TAG}
    # TODO: Probably need to only exec into "$@" if there are more args
    "$@"
}
set_awx_docker_cmd() {
    export AWX_DOCKER_CMD="$1"
    shift
    "$@"
}
set_version() {
    # set_version will set VERSION and the COLLECTION_VERSION vars
    # to force a VERSION string and prevent any version gathering
    # that the Makefile does from running.
    VERSION="$1"
    shift
    COLLECTION_VERSION="$(echo "$VERSION" | cut -d . -f 1-3)"
    export VERSION
    export COLLECTION_VERSION
    "$@"
}
git_branch() {
    git rev-parse --abbrev-ref HEAD
}
stub_github_env () {
    export CI_GITHUB_TOKEN="fakeass-gh-token"
    export GITHUB_ACTOR="fakeass-gh-actor"
}
do_ci() {
    if [[ $# -gt 0 ]]; then
        sub="$1"
        shift
        case $sub in
            github-ci-runner-api-tests)
                # This is the "normal" flow that's called from github
                # It's got some issues that we can get around, though
                # Like, `github_ci_runner` depends on `github_ci_setup`
                # which *forces* a call to `$(MAKE) docker-compose-build`
                # even though that might be totally unnecessary (e.g.,
                # we can just run the tests with the pulled image?)
                # So, I will provide another path that tries to avoid that.

                # Since the make rule will force docker compose build, we should
                # make sure we have some stuff first:
                command -v ansible-playbook || error "No ansible-playbook command available"
                command -v docker-compose || error "No docker-compose command available"
                stub_github_env
                export AWX_DOCKER_CMD=/start_tests.sh
                # Let's try to force devel for now. Fix this later because
                # probably not everyone will want it. I just want to see
                # what it does v. my other runners.
                set_branch devel set_version 0.1.dev make AWX_DOCKER_CMD=/start_tests.sh github_ci_runner
            ;;
            make-docker-runner-api-tests)
                # This one still uses make but calls directly `make docker-runner`
                # which, amazingly, has no pre-requisites/depdendencies in the Makefile :)
                # So, it shouldn't force make docker-compose-build like the other one does
                stub_github_env  # I don't think I need this here
                # See start_tests.sh; without args it falls through and calls `make test` from within the container
                export AWX_DOCKER_CMD=/start_tests.sh
                set_branch devel set_version 0.1.dev set_awx_docker_cmd /start_tests.sh make docker-runner
            ;;
            docker-api-tests)
                # This one goes straight to running docker without calling make on the host at all
                # Funny that this doesn't care about a version or anything.
                # I guess it kind of assumes that the image exists.
                # TODO(jjwatt): If we're going to do this, then add error handling for image existence
                stub_github_env # just in case?
                : "${UID:=$(id -u)}"
                : "${PWD:=$(pwd)}"
                : "${DEVEL_IMAGE_NAME:=devel}"
                : "${AWX_DOCKER_CMD:=/start_tests.sh}"
                export UID PWD DEVEL_IMAGE_NAME AWX_DOCKER_CMD
                "${DOCKER:-docker}" run -u "${UID}" --rm \
                            -v "${PWD}":/awx_devel:Z \
                            --workdir=/awx_devel "${DEVEL_IMAGE_NAME}" \
                            "${AWX_DOCKER_CMD}"
            ;;
            *)
                # TODO: Maybe run a default, or maybe take the command from the args
                echo set_branch devel set_version 0.1.dev "${sub}"
        esac
    else
        echo "No args to do_ci. DEBUGGING echo: "
        echo set_branch devel set_version 0.1.dev make tests
    fi
}
sh_main() {
    # TODO: This gitbranch call should probably be somewhere else.
    export GIT_BRANCH="$(git_branch)"
    echo "THIS PART WOULD RUN IN GITHUB ACTIONS VM"
    echo "# and @ from sh_main: $# , $*"
    if [[ $# -gt 0 ]]; then
        sub="$1"
        shift
        case $sub in
            nukepip)
                pip_uninstalls
            ;;
            test)
                # Let's just test running api-tests at first for now
                set_branch devel set_version 0.1.dev make print-VERSION
            ;;
            ci)
                do_ci "$@"
            ;;
            *)
                echo "unknown subcommand: $sub"
            ;;
        esac

    fi
}
test_sh_main () {
    echo $"@"
    sh_main "$@"
    # printf "DEVEL_IMAGE_NAME: %s\n" ${DEVEL_IMAGE_NAME} || :
    # printf "DEV_DOCKER_TAG_BASE: %s\n" ${DEV_DOCKER_TAG_BASE} || :
    # printf "COMPOSE_TAG: %s\n" ${COMPOSE_TAG} || :
}
## MAIN CALL ##
test_sh_main "$@"
