#!/bin/bash

# ▄████▄   ██▓ ███▄ ▄███▓ █    ██ 
# ▒██▀ ▀█  ▓██▒▓██▒▀█▀ ██▒ ██  ▓██▒
# ▒▓█    ▄ ▒██▒▓██    ▓██░▓██  ▒██░
# ▒▓▓▄ ▄██▒░██░▒██    ▒██ ▓▓█  ░██░
# ▒ ▓███▀ ░░██░▒██▒   ░██▒▒▒█████▓ 
# ░ ░▒ ▒  ░░▓  ░ ▒░   ░  ░░▒▓▒ ▒ ▒ 
# ░  ▒    ▒ ░░  ░      ░░░▒░ ░ ░ 
# ░         ▒ ░░      ░    ░░░ ░ ░ 
# ░ ░       ░         ░      ░     
# ░                                
# Tool that can run AWX GitHub Actions runs, but different.
# 0.2.0 "Switches on Everything"
# CIMU_VERSION=0.2.0

# NOTE: There's a great-looking github action local runner here:
#   https://github.com/nektos/act
# GitHub's full-blown runner is here:
#   https://github.com/actions/runner
# But, for now I think this will do the trick.

# Colors
# Variables for terminal requests.
# shellcheck disable=SC2034
# shellcheck disable=SC2015
[[ -t 2 ]] && {
    alt=$(      tput smcup  || tput ti      ) # Start alt display
    ealt=$(     tput rmcup  || tput te      ) # End   alt display
    hide=$(     tput civis  || tput vi      ) # Hide cursor
    show=$(     tput cnorm  || tput ve      ) # Show cursor
    save=$(     tput sc                     ) # Save cursor
    load=$(     tput rc                     ) # Load cursor
    bold=$(     tput bold   || tput md      ) # Start bold
    stout=$(    tput smso   || tput so      ) # Start stand-out
    estout=$(   tput rmso   || tput se      ) # End stand-out
    under=$(    tput smul   || tput us      ) # Start underline
    eunder=$(   tput rmul   || tput ue      ) # End   underline
    reset=$(    tput sgr0   || tput me      ) # Reset cursor
    blink=$(    tput blink  || tput mb      ) # Start blinking
    italic=$(   tput sitm   || tput ZH      ) # Start italic
    eitalic=$(  tput ritm   || tput ZR      ) # End   italic
[[ $TERM != *-m ]] && { 
    red=$(      tput setaf 1|| tput AF 1    )
    green=$(    tput setaf 2|| tput AF 2    )
    yellow=$(   tput setaf 3|| tput AF 3    )
    blue=$(     tput setaf 4|| tput AF 4    )
    magenta=$(  tput setaf 5|| tput AF 5    )
    cyan=$(     tput setaf 6|| tput AF 6    )
}
    white=$(    tput setaf 7|| tput AF 7    )
    default=$(  tput op                     )
    eed=$(      tput ed     || tput cd      )   # Erase to end of display
    eel=$(      tput el     || tput ce      )   # Erase to end of line
    ebl=$(      tput el1    || tput cb      )   # Erase to beginning of line
    ewl=$eel$ebl                                # Erase whole line
    draw=$(     tput -S <<< '   enacs
                                smacs
                                acsc
                                rmacs' || { \
                tput eA; tput as;
                tput ac; tput ae;         } )   # Drawing characters
    back=$'\b'
} 2>/dev/null ||:

# The above leaves the variables unset when stderr isn't connected to a terminal
# and leaves the color variables unset for monochrome terminals. The alternative
# tput executions allow the code to keep working on systems where tput takes old
# termcap names instead ANSI capnames. It also uses 2>/dev/null ||: to silence
# potential errors and avoid ERR script abortion. That allows this code to be
# used in a range of edge cases such as scripts that use set -e and terminals or
# OS's that don't support certain sequences (the code is borrowed from
# https://github.com/lhunath/scripts/blob/master/bashlib/bashlib )

# We're evolving into a tool for bootstrapping, wrapping and running tests and
# dev instances of AWX.
: "${CIMU_DEFAULT_STUB_VERSION:=0.1.dev}"
export CIMU_DEFAULT_STUB_VERSION
error () {
	  echo >&2 "error: $*"
	  exit 1
}
install_deps_rhel8() {
    # Install deps that I needed on rhel8 in order to use
    # the awx repo, dev and build tools.
    # I'm not sure what's needed on other environments right now,
    # but I know I've done similar installs on Fedora {37,38}
    # too.
    sudo dnf install openldap-devel \
        postgresql postgresql-devel \
        xmlsec1-devel libxml2-devel \
        libtool-ltdl-devel
}
# Stash the realmake early in case we clobber it or need to call it at a different level
realmake=$(command -v make)
envmake() {
    # envmake will run make and use environment variables to override any
    # make variables.
    echo "inside envmake about to call realmake with overrides" >&2
    echo "realmake is: ${realmake}" >&2
    echo "version env vars from envmake(): VERSION=${VERSION}, COLLECTION_VERSION=${COLLECTION_VERSION}" >&2
    "${realmake}" --environment-overrides "$@"
}
make() {
    envmake "$@"
}
# TODO(jjwatt): define docker(), too so that I can control calls to that.
# e.g., probably want to capture calls to 'docker info' to avoid bugs
# in the main.yml playbook and getting os info.
pip_uninstalls() {
    # TODO: ihateyoupip array and try to uninstall all of it
    pip uninstall -y setuptools-scm ansible-core || :
}
set_branch() {
    # set_branch will set the GIT_BRANCH, COMPOSE_TAG, DEV_DOCKER_TAG_BASE,
    # and DEVEL_IMAGE_NAME to the right stuff like the Makefile does.
    # Use this to force pulling the devel docker image or an arbitrary
    # docker image vs. needing to build your own.
    export GIT_BRANCH="$1"
    shift
    export COMPOSE_TAG="${GIT_BRANCH}"
    # All this just stolen from the Makefile for now
    # TODO(jjwatt): Refactor
    export DEV_DOCKER_TAG_BASE=${DEV_DOCKER_TAG_BASE:-ghcr.io/ansible}
    export DEVEL_IMAGE_NAME=${DEV_DOCKER_TAG_BASE}/awx_devel:${COMPOSE_TAG}
    # TODO: Probably need to only exec into "$@" if there are more args
    "$@"
}
set_awx_docker_cmd() {
    export AWX_DOCKER_CMD="$1"
    shift
    "$@"
}
set_version() {
    # set_version will set VERSION and the COLLECTION_VERSION vars
    # to force a VERSION string and prevent any version gathering
    # that the Makefile does from running.
    VERSION="$1"
    shift
    COLLECTION_VERSION="$(echo "$VERSION" | cut -d . -f 1-3)"
    export VERSION
    export COLLECTION_VERSION
    "$@"
}
git_branch() {
    git rev-parse --abbrev-ref HEAD
}
stub_github_env () {
    export CI_GITHUB_TOKEN="fakeass-gh-token"
    export GITHUB_ACTOR="fakeass-gh-actor"
}
do_ci() {
    # TODO: Make self-documenting by tagging user-level functions with comments
    # or by name or something.
    # TODO: Accept flag somewhere for version/stubver so it's
    # more discoverable a setting than an env var.
    local _stubver="${CIMU_DEFAULT_STUB_VERSION:-0.1.dev}"
    if [[ $# -gt 0 ]]; then
        sub="$1"
        shift
        case $sub in
            github-ci-runner-api-tests)
                # This is an improved version of the "normal" flow that's called
                # from github It's got some issues that we can get around,
                # though Like, `github_ci_runner` depends on `github_ci_setup`
                # which *forces* a call to `$(MAKE) docker-compose-build` even
                # though that might be totally unnecessary (e.g., we can just
                # run the tests with the pulled image?) So, I will provide
                # another path that tries to avoid that.

                # Since the make rule will force docker compose build, we should
                # make sure we have some stuff first:
                command -v ansible-playbook || error "No ansible-playbook command available"
                command -v docker-compose || error "No docker-compose command available"
                stub_github_env
                export AWX_DOCKER_CMD=/start_tests.sh
                # Let's try to force devel for now. Fix this later because
                # probably not everyone will want it. I just want to see
                # what it does v. my other runners.
                set_branch devel set_version "${_stubver}" make AWX_DOCKER_CMD=/start_tests.sh github_ci_runner
            ;;
            make-docker-runner-api-tests)
                # This one still uses make but calls directly `make docker-runner`
                # which, amazingly, has no pre-requisites/depdendencies in the Makefile :)
                # So, it shouldn't force make docker-compose-build like the other one does
                stub_github_env  # I don't think I need this here
                # See start_tests.sh; without args it falls through and calls `make test` from within the container
                export AWX_DOCKER_CMD=/start_tests.sh
                set_branch devel set_version "${_stubver}" set_awx_docker_cmd /start_tests.sh make docker-runner
            ;;
            docker-api-tests)
                # This one goes straight to running docker without calling make on the host at all
                # Funny that this doesn't care about a version or anything.
                # I guess it kind of assumes that the image exists.
                # TODO(jjwatt): If we're going to do this, then add error handling for image existence
                stub_github_env # just in case?
                : "${UID:=$(id -u)}"
                : "${PWD:=$(pwd)}"
                : "${DEVEL_IMAGE_NAME:=devel}"
                : "${AWX_DOCKER_CMD:=/start_tests.sh}"
                export UID PWD DEVEL_IMAGE_NAME AWX_DOCKER_CMD
                "${DOCKER:-docker}" run -u "${UID}" --rm \
                            -v "${PWD}":/awx_devel:Z \
                            --workdir=/awx_devel "${DEVEL_IMAGE_NAME}" \
                            "${AWX_DOCKER_CMD}"
            ;;
            *)
                # TODO: Maybe run a default, or maybe take the command from the args
                echo set_branch devel set_version "${_stubver}" "${sub}"
        esac
    else
        echo "No args to do_ci. DEBUGGING echo: "
        echo set_branch devel set_version "${_stubver}" make tests
    fi
}
make_docker_compose_sources() {
    # Do the same thing `make docker-compose-sources` would do, but without make
    # and everything is hackable through setting vars before calling.
    : "${playbookbin:=ansible-playbook}"
    : "${minikube_playbook:=tools/docker-compose-minikube/deploy.yml}"
    : "${sources_inventory:=tools/docker-compose/inventory}"
    if [[ $MINIKUBE_CONTAINER_GROUP ]]; then
        "${playbookbin}" -i "${sources_inventory}" \
                         -e minikube_setup="${MINIKUBE_SETUP}" \
                         "${minikube_playbook}"
    fi
    : "${sources_playbook:=tools/docker-compose/ansible/sources.yml}"
    # NOTE: I do not directly ensure, test or override any of these in this
    # function because this function is a runner. You override the vars and
    # then call this or call it from one of my env exec chain functions.
    # That design idea makes sure that this stays both as close to the
    # original/makefile one as possible *and* it is maximally hackable.
    # Do any hard setup or making sure the vars are setup properly from
    # somewhere else and then "call into" this function.
    # TODO: Handle the vars with an array and a loop, maybe a fn for
    #       writing the command intelligently.
    "${playbookbin}" -i "${sources_inventory}" \
                     "${sources_playbook}" \
                     -e awx_image="${DEV_DOCKER_TAG_BASE}"/awx_devel \
                     -e awx_image_tag="${COMPOSE_TAG}" \
                     -e receptor_image="${RECEPTOR_IMAGE}" \
                     -e control_plane_node_count="${CONTROL_PLANE_NODE_COUNT}" \
                     -e execution_node_count="${EXECUTION_NODE_COUNT}" \
                     -e minikube_container_group="${MINIKUBE_CONTAINER_GROUP}" \
                     -e enable_keycloak="${KEYCLOAK}" \
                     -e enable_ldap="${LDAP}" \
                     -e enable_splunk="${SPLUNK}" \
                     -e enable_prometheus="${PROMETHEUS}" \
                     -e enable_grafana="${GRAFANA}" \
                     -e enable_tacacs="${TACACS}" \
                     "${EXTRA_SOURCES_ANSIBLE_OPTS}"
}
realdocker="$(command -v docker)"
my_docker() {
    if [[ $1 ]]; then
        case $1 in
            info)
                echo "Operating System: Linux"
            ;;
            *)
                "${realdocker}" "$@"
            ;;
        esac
    fi
}
docker() {
    my_docker "$@"
}
my_make_docker_compose_sources() {
    # What I want to do is make sure the bad os info call does not run,
    # but maybe there are ways to make sure other stuff doesn't run using
    # changed_when
    # Try setting os_info in EXTRA_SOURCES_ANSIBLE_OPTS and calling into
    # make_docker_compose_sources
    # TODO: set or append
    # TODO: Make a file and use @filename.yml to -e
    # TODO: Should probably do that ^^ for all the vars
    tmpfile="$(mktemp XXXXX.yml)"
    cat > "$tmpfile" <<-EOF
        os_info:
            stdout: Linux
EOF
    EXTRA_SOURCES_ANSIBLE_OPTS="-e @${tmpfile}"
    trap 'rm -rf ${tmpfile}' EXIT
    # Still does not seem to stop the Get OS info from running
    # TODO: Maybe try rewriting the playbook and using the new one
    # Maybe just fix it with sed for now
    export EXTRA_SOURCES_ANSIBLE_OPTS
    : "${RECEPTOR_IMAGE:=quay.io/ansible/receptor:devel}"
    export RECEPTOR_IMAGE
    : "${CONTROL_PLANE_NODE_COUNT:=1}"
    export CONTROL_PLANE_NODE_COUNT
    : "${EXECUTION_NODE_COUNT:=1}"
    export EXECUTION_NODE_COUNT
    : "${KEYCLOAK:=false}"
    export KEYCLOAK
    : "${LDAP:=false}"
    export LDAP
    : "${SPLUNK:=false}"
    export SPLUNK
    : "${PROMETHEUS:=false}"
    export PROMETHEUS
    : "${GRAFANA:=false}"
    export GRAFANA
    : "${TACACS:=false}"
    export TACACS
    # Just setting branch and version for now, but use env later
    # or make this a middleware fn itself and call back out to the
    # next program so we can chain into this
    set_branch devel set_version 0.1.dev make_docker_compose_sources
    # TODO: write a function that just runs the os info task
    # TODO: This could be "set_os" if I can get it to work
    # NOTE: don't forget that os_info is a struct :/ need os_info.stdout
    # NOTE: may be able to write out a tools/docker-compose/host_vars/localhost
    #       with modified vars in it and it could get picked up automatically
    # NOTE: ansible-playbook has --start-at-task
}
sh_main() {
    # TODO: This gitbranch call should probably be somewhere else.
    [[ $GIT_BRANCH ]] || GIT_BRANCH="$(git_branch)"
    export GIT_BRANCH
    printf "%sSwitches on Everything!%s\n" "${blue}" "${reset}"
    echo "${red}THIS PART WOULD RUN IN GITHUB ACTIONS VM${reset}"
    echo "${green}# and @ from sh_main: $# , $* ${reset}"
    if [[ $# -gt 0 ]]; then
        sub="$1"
        shift
        case $sub in
            unpip)
                pip_uninstalls
            ;;
            test-version)
                local _stubver=0.1.dev
                set_branch devel set_version "${_stubver}" make print-VERSION
            ;;
            test-playbook-os-info)
                _stubver=0.1.dev
                my_make_docker_compose_sources
            ;;
            test-my-docker)
                docker info | grep 'Operating System'
            ;;
            install-deps-rhel8)
                install_deps_rhel8
            ;;
            ci)
                do_ci "$@"
            ;;
            self-lint)
                shellcheck "${BASH_SOURCE[0]}"
            ;;
            *)
                echo "unknown subcommand: $sub"
            ;;
        esac

    fi
}
## MAIN CALL ##
sh_main "$@"
